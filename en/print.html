<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>yu book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1.介绍.html"><strong aria-hidden="true">1.</strong> Introduce</a></li><li class="chapter-item expanded "><a href="2.快速开始.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="3.基本原理.html"><strong aria-hidden="true">3.</strong> Fundamental</a></li><li class="chapter-item expanded "><a href="4.0组件.html"><strong aria-hidden="true">4.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.1blockchain.html"><strong aria-hidden="true">4.1.</strong> blockchain</a></li><li class="chapter-item expanded "><a href="4.2txdb.html"><strong aria-hidden="true">4.2.</strong> txdb</a></li><li class="chapter-item expanded "><a href="4.3txpool.html"><strong aria-hidden="true">4.3.</strong> txpool</a></li><li class="chapter-item expanded "><a href="4.4tripod.html"><strong aria-hidden="true">4.4.</strong> tripod</a></li><li class="chapter-item expanded "><a href="4.5state.html"><strong aria-hidden="true">4.5.</strong> state</a></li><li class="chapter-item expanded "><a href="4.6p2p.html"><strong aria-hidden="true">4.6.</strong> p2p</a></li></ol></li><li class="chapter-item expanded "><a href="5.0dev.html"><strong aria-hidden="true">5.</strong> Development Manual</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.1配置文件.html"><strong aria-hidden="true">5.1.</strong> Config File</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.1.1节点配置.html"><strong aria-hidden="true">5.1.1.</strong> Node Config</a></li><li class="chapter-item expanded "><a href="5.1.2各组件配置.html"><strong aria-hidden="true">5.1.2.</strong> Config of each component</a></li><li class="chapter-item expanded "><a href="5.1.3P2P网络配置.html"><strong aria-hidden="true">5.1.3.</strong> Config of P2P</a></li></ol></li><li class="chapter-item expanded "><a href="5.2context与chainEnv.html"><strong aria-hidden="true">5.2.</strong> Context and chainEnv</a></li><li class="chapter-item expanded "><a href="5.3writing_and_reading.html"><strong aria-hidden="true">5.3.</strong> Writing and Reading</a></li><li class="chapter-item expanded "><a href="5.4区块周期.html"><strong aria-hidden="true">5.4.</strong> block life cycle</a></li><li class="chapter-item expanded "><a href="5.5建立区块链网络.html"><strong aria-hidden="true">5.5.</strong> Build Blockchain Network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.5.1节点1.html"><strong aria-hidden="true">5.5.1.</strong> node1 Conf</a></li><li class="chapter-item expanded "><a href="5.5.2节点2.html"><strong aria-hidden="true">5.5.2.</strong> node2 Conf</a></li><li class="chapter-item expanded "><a href="5.5.3节点3.html"><strong aria-hidden="true">5.5.3.</strong> node3 Conf</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">yu book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduce" id="introduce">Introduce</a></h1>
<p>Yu is an easy-to-use and highly customizable blockchain framework developed in golang. 
Most of the existing blockchains (Public Blockchain and Consortium Blockchain) can be developed with yu.</p>
<h3><a class="header" href="#why-do-this" id="why-do-this">Why do this?</a></h3>
<p>The current blockchain framework either has a high threshold for getting started, or the degree of customization is very low, or the community is inactive and has stopped maintenance. So I developed it myself
This blockchain framework. The purpose is to allow developers to get started with the core of blockchain development more easily, quickly and deeply.</p>
<h3><a class="header" href="#what-functions-can-yu-customize" id="what-functions-can-yu-customize">What functions can Yu customize</a></h3>
<ul>
<li>Customized consensus algorithms, including but not limited to pow, pos, poa, pbft, etc.</li>
<li>Custom block verification logic, transaction verification logic, rules for packaging transactions from the transaction pool.</li>
<li>Insert custom actions at various stages of the block generation cycle, including controlling when transactions are executed.</li>
<li>Custom on-chain transactions (ie Writing, called transactions in Ethereum) and queries</li>
<li>Custom chain structure (including fork logic) and transaction pool logic</li>
<li>Can be developed in multiple programming languages (not yet finished)</li>
<li>You can use [dependency injection] to manage each business module (Tripod)  </li>
</ul>
<h1><a class="header" href="#quick-start" id="quick-start">Quick Start</a></h1>
<h4><a class="header" href="#install" id="install">Install</a></h4>
<pre><code>go get github.com/yu-org/yu
</code></pre>
<h4><a class="header" href="#develop-an-on-chain-writing-and-reading" id="develop-an-on-chain-writing-and-reading">Develop an on-chain <code>Writing</code> and <code>Reading</code></a></h4>
<pre><code class="language-go">import (
	&quot;github.com/yu-org/yu/apps/pow&quot;
	. &quot;github.com/yu-org/yu/core/types&quot;
	&quot;github.com/yu-org/yu/env&quot;
	&quot;github.com/yu-org/yu/common&quot;
	&quot;github.com/yu-org/yu/context&quot;
	&quot;github.com/yu-org/yu/startup&quot;
	&quot;github.com/yu-org/yu/tripod&quot;
)

type Example struct {
	*tripod.Tripod
}

// Here is a custom development of a Writing
func (e *Example) WriteA(ctx *context.WriteContext) error {
	caller := ctx.GetCaller()
	// set this Writing lei cost (lei and gas are synonymous)
	ctx.SetLei(100) 
	// Store data in on-chain state.
	e.Set(caller.Bytes(), []byte(&quot;yu&quot;)) 
	// Emit an event.
	ctx.EmitStringEvent(&quot;execute success&quot;)
	return nil
}

// Here is a custom development of a Reading
func (e *Example) ReadA(ctx *context.ReadContext) {
    key := ctx.GetString(&quot;key&quot;)
    value, err := e.Get(key.Bytes())
    if err != nil {
        return err
    }
    ctx.String(string(value))
    return nil
}

</code></pre>
<h4><a class="header" href="#add-tripods-in-the-main-function" id="add-tripods-in-the-main-function">Add tripods in the main function</a></h4>
<pre><code class="language-go">func NewExample() *Example {
	df := tripod.NewTripod()
	e := &amp;Example{df}

	// Here you need to manually register the custom Writing to tripod，
	e.SetWritings(e.WriteA)
	// Here you need to manually register the custom Reading into tripod
	e.SetReadings(e.ReadA)

	return e
}

func main() {
	poaConf := poa.DefaultCfg(0)
	startup.InitDefaultKernelConfig()
	startup.DefaultStartup(poa.NewPoa(poaConf), NewExample())
}
</code></pre>
<h4><a class="header" href="#run" id="run">Run</a></h4>
<pre><code class="language-zsh">go build -o yu-poa-example

./yu-poa-example  
 
</code></pre>
<p>At this point, a blockchain has been activated. In the future, more blockchain nodes can be added to <a href="5.5%E5%BB%BA%E7%AB%8B%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C.html">build a blockchain network</a>。</p>
<h1><a class="header" href="#fundamental" id="fundamental">Fundamental</a></h1>
<h3><a class="header" href="#process-overview" id="process-overview">Process overview</a></h3>
<p><img src="yu_flow_chart.png" alt="image" /></p>
<p>When a transaction is initiated from the client to the chain, it will first be checked by <code>txpool</code>, and only after the check is passed will it be put into the transaction pool and broadcast to other blockchain nodes.
Receive transactions broadcast from other nodes in the P2P network, and put them into <code>txpool</code> after checking (no longer broadcast) </p>
<p><code>land</code> runs, starts generating blocks, and performs a series of processing on blocks: including mining blocks, broadcasting, validating blocks from other nodes, executing intra-block transactions, storing blocks on the chain, etc. . During this process
There are so many things that can be freely controlled, and you can use it to implement any consensus algorithm, sharding method, block time, package transaction method, choose when to execute transactions, etc. you want. with <code>blockchain</code>,
The interaction of <code>txdb</code>, <code>state</code> is also in this process.</p>
<p>After each block goes through all the custom <code>tripod</code> logic in <code>land</code>, it will enter the next block stage, generate the next block and process it, and the cycle goes on and on.</p>
<h1><a class="header" href="#components" id="components">Components</a></h1>
<h4><a class="header" href="#core-components" id="core-components">Core components</a></h4>
<p>The following <code>blockchain</code>, <code>txdb</code>, <code>txpool</code> are all interfaces, with built-in default implementations, 
if developers have special needs, they can re-implement the interfaces themselves:</p>
<ul>
<li>blockchain: Chain structure, responsible for storing block data and organizing chain structure and fork logic.</li>
<li>txdb: The database of <code>yu</code>, which stores the specific transaction data in all blocks, <code>event</code> and <code>error</code> after the transaction is executed.</li>
<li>txpool: The transaction pool is responsible for validating and caching transactions sent from outside.</li>
<li>state: Storage state, which stores the state after each transaction(Writing) is executed, such as account balance.</li>
<li>tripod: The basic minimum unit that runs the blockchain and allows developers to customize logic. 
Developers can customize multiple tripods and load their ordered combinations into <code>land</code> for the framework to call.</li>
</ul>
<h4><a class="header" href="#low-level-components" id="low-level-components">Low-level components</a></h4>
<ul>
<li>store: The storage layer supports various forms of storage such as kv, sql, and fs, and they are all interfaces. Developers can specify the required storage engine (for example, kv currently has two storage engines, <code>badger</code> and <code>boltdb</code>)
Currently the storage in <code>state</code> is implemented using <code>boltdb</code>, while the storage in <code>blockchain</code> and <code>txdb</code> is implemented using <code>sqlite</code>.</li>
<li>p2p: A peer-to-peer transport network, used to discover nodes in the network and propagate transactions and blocks, etc. </li>
<li>keypair: Asymmetric encryption algorithm for public and private keys, currently supports <code>sr25519</code> and <code>ed25519</code>. 
This component is in the form of an interface and can extend other encryption algorithms by itself.</li>
</ul>
<p><img src="yu_arch.png" alt="image" /></p>
<h1><a class="header" href="#blockchain" id="blockchain">Blockchain</a></h1>
<p>The <code>blockchain</code> component is the persistent storage of the blockchain structure, and the chain structure maintained by the entire network. Note: This structure does not store specific transaction data and transaction Writing results. This part of the data is stored in <code>txdb</code>.</p>
<h3><a class="header" href="#interface" id="interface">Interface</a></h3>
<p>Code is <a href="https://github.com/yu-org/yu/blob/master/core/blockchain/blockchain.go">here</a><br />
<code>blockchain</code> implements the storage and processing logic of the basic chain structure. The following are the interfaces of the core functions. Developers can customize their own chain storage methods and processing logic if required: </p>
<pre><code class="language-go">func ConvergeType() ConvergeType
</code></pre>
<p><code>ConvergeType()</code> returns the convergence type of the chain (that is, in what form the block was finalized)
As we all know, in the blockchain, multiple nodes may produce blocks at the same moment, thus forming a fork. If it does not converge, the system will not know which chain is the main chain. Therefore, convergence is required, and the most common methods of convergence are:</p>
<ul>
<li>
<p>Longest sub-chain (Longest): The longest branch will be considered as the main chain, and this method will be rolled back.</p>
</li>
<li>
<p>Heaviest: The fork with the largest number of sub-chains will be considered as the main chain, and this method will be rolled back.</p>
</li>
<li>
<p>Finalize: The block or chain is voted through voting and other methods to finally finalize a fork to become the main chain. Under normal circumstances, the finalized block cannot be rolled back.</p>
</li>
</ul>
<h2><a class="header" href="#" id=""></a></h2>
<pre><code class="language-go">func GetGenesis() (*CompactBlock, error)
func SetGenesis(b *CompactBlock) error
</code></pre>
<p>Obtain the genesis block from the chain and store the genesis block into the chain.</p>
<h2><a class="header" href="#-1" id="-1"></a></h2>
<pre><code class="language-go">func AppendBlock(b *CompactBlock) error
func GetBlock(blockHash Hash) (*CompactBlock, error)
func UpdateBlock(b *CompactBlock) error
</code></pre>
<p><code>AppendBlock(block)</code>adds the block to the end of the chain<br />
<code>GetBlock(blockHash)</code>gets a specific block based on the block hash<br />
<code>UpdateBlock(block)</code>updates block data with block hash as index</p>
<h2><a class="header" href="#-2" id="-2"></a></h2>
<pre><code class="language-go">func Children(prevBlockHash Hash) ([]*CompactBlock, error)  
func Finalize(blockHash Hash) error  
func GetEndBlock() (*CompactBlock, error)
func LastFinalized() (*CompactBlock, error)
</code></pre>
<p><code>Children(blockHash)</code> gets all its subblocks based on a block hash<br />
<code>Finalize(blockHash)</code> finals consensus finalizes a block<br />
<code>GetEndBlock()</code> gets the last unfinalized block<br />
<code>LastFinalized()</code> gets the last finalized block</p>
<h1><a class="header" href="#txdb" id="txdb">txdb</a></h1>
<p><code>txdb</code> stores specific transaction data in all blocks, <code>event</code> and <code>error</code> after the transaction is executed.</p>
<h3><a class="header" href="#interface-1" id="interface-1">Interface</a></h3>
<p>Code is <a href="https://github.com/yu-org/yu/blob/master/core/txdb/txdb.go">here</a><br />
The following are the interfaces of the core functions. Developers can customize their own <code>txdb</code> if required.</p>
<pre><code class="language-go">func GetTxn(txnHash Hash) (*SignedTxn, error)
func SetTxn(stxn *SignedTxn) error
</code></pre>
<p><code>GetTxn(txnHash)</code> gets transaction data based on the hash value of the transaction<br />
<code>SetTxn(stxn)</code> stores transaction data in the <code>txdb</code> (indexed by transaction hash)）</p>
<h2><a class="header" href="#-3" id="-3"></a></h2>
<pre><code class="language-go">func GetTxns(blockHash Hash) ([]*SignedTxn, error)
func SetTxns(blockHash Hash, txns []*SignedTxn) error
</code></pre>
<p><code>GetTxns(blockHash)</code> gets all transaction data in the block according to the block hash<br />
<code>SetTxns(blockHash, txns)</code> stores all transaction data in a block into txdb（Indexed by transaction hash）</p>
<h2><a class="header" href="#-4" id="-4"></a></h2>
<pre><code class="language-go">func GetEvents(blockHash Hash) ([]*Event, error)
func SetEvents(events []*Event) error
</code></pre>
<p><code>GetEvents(blockHash)</code> gets all <code>event</code>s in the block according to the block hash<br />
<code>SetEvents(events）</code> stores all <code>event</code> in <code>txdb</code> (indexed by auto-incrementing ID)</p>
<h2><a class="header" href="#-5" id="-5"></a></h2>
<pre><code class="language-go">func GetErrors(blockHash Hash) ([]*Error, error)
func SetError(err *Error) error
</code></pre>
<p><code>GetErrors(blockHash)</code> gets all <code>error</code> in the block according to the block hash<br />
<code>SetError(err)</code> stores all <code>error</code> in txdb (indexed by auto-incrementing ID)</p>
<h1><a class="header" href="#txpool" id="txpool">Txpool</a></h1>
<p>Code is <a href="https://github.com/yu-org/yu/blob/master/core/txpool/txpool.go">here</a><br />
The following are the interfaces of the core functions. Developers can customize their own trading pools if required.</p>
<pre><code class="language-go">func BaseCheck(*SignedTxn) error
func TripodsCheck(stxn *SignedTxn) error
func NecessaryCheck(stxn *SignedTxn) error
</code></pre>
<p><code>BaseCheck()</code>: when inserts transaction data into the transaction pool, it will do some basic checks. The basic checks are: whether the transaction data is too large, whether the transaction pool capacity has reached the upper limit, whether the signature in the transaction is legal, whether there is
Transactions are repeated. The first three will return an error if the check fails. When the transaction is repeated, the message will be ignored but no error will be returned.</p>
<p><code>TripodsCheck()</code>: After the basic check of <code>TripodsChecks</code>, the tripods check will be performed, which is the transaction check rule defined by the developer.</p>
<p><code>NecessaryCheck()</code> represents a necessity check, which only checks whether the transaction data is too large, whether the signature is valid, and the tripods check. After the node receives the block from the P2P network, the synchronization
Check the transaction data in the block, and directly store it in <code>txdb</code> after checking.</p>
<h2><a class="header" href="#-6" id="-6"></a></h2>
<pre><code class="language-go">func Insert(txn *SignedTxn) error
</code></pre>
<p><code>Insert()</code> means inserting transaction data into the transaction pool. This function has two types of checks, <code>BaseCheck</code> and <code>TripodsCheck</code>. Only after passing the check will it be inserted into the transaction pool, otherwise an error will be returned.</p>
<h2><a class="header" href="#-7" id="-7"></a></h2>
<pre><code class="language-go">func Pack(numLimit uint64) ([]*SignedTxn, error)
func PackFor(numLimit uint64, filter func(*SignedTxn) error) ([]*SignedTxn, error)
</code></pre>
<p><code>Pack(numLimit)</code> means to pack a maximum of <code>numLimit</code> transactions from the transaction pool. The packaged transactions will be marked, but will not be deleted from the transaction pool immediately.<br />
<code>PackFor(numLimit, filter)</code> has one more filter function than <code>Pack</code>. All packed transactions must pass the filter of <code>filter</code>. If <code>filter</code> returns an error, the transaction will not be packed.</p>
<h2><a class="header" href="#-8" id="-8"></a></h2>
<pre><code class="language-go">func GetTxn(hash Hash) (*SignedTxn, error)
func Reset(*Block) error
</code></pre>
<p><code>GetTxn(hash)</code> gets transaction data according to the transaction hash value<br />
<code>Reset(*Block)</code> clears the transactions in the given block from the transaction pool as they are already packed.</p>
<h1><a class="header" href="#tripod" id="tripod">Tripod</a></h1>
<h4><a class="header" href="#description" id="description">Description</a></h4>
<p><code>tripod</code> is the core of the entire yu framework, and developers define their own business logic by implementing its interface. It consists of three parts:</p>
<ol>
<li>Custom block verification rules and transaction checking logic.</li>
<li>Control the life cycle of blocks to achieve deep customization development. The life cycle has four phases: <code>initChain</code>, <code>startBlock</code>, <code>endBlock</code>, <code>finalizeBlock</code>. where only <code>initChain</code>
It is called only at the time of the genesis block, and the last three are called every block. (Personalized consensus algorithms can be implemented with the block life cycle)</li>
<li>Customize <code>Transaction</code>(Writing), <code>Query</code>(Query) and <code>P2P Request Handling</code> (p2pHandler) </li>
</ol>
<h4><a class="header" href="#interface-2" id="interface-2">Interface</a></h4>
<p>Code is <a href="https://github.com/yu-org/yu/blob/master/core/tripod/tripod.go">here</a></p>
<pre><code class="language-go">func Name() string
func SetChainEnv(env *ChainEnv)
</code></pre>
<p><code>Name()</code> returns the name of <code>tripod</code>。<br />
<code>SetChainEnv(*ChainEnv)</code> loads <code>ChainEnv</code> into <code>tripod</code>, which is convenient for subsequent calls. (<code>ChainEnv</code> is introduced in <a href="5.2context%E4%B8%8EchainEnv.html">context and chainEnv</a>)</p>
<h2><a class="header" href="#-9" id="-9"></a></h2>
<pre><code class="language-go">func CheckTxn(*SignedTxn) error
func VerifyBlock(block *Block) bool
</code></pre>
<p><code>checkTxn()</code> is a developer-defined transaction check logic. As mentioned in the previous chapter, when an external transaction is inserted into <code>txpool</code>, the two steps of <code>BaseChack</code> and <code>TripodsCheck</code> will be executed.
And <code>TripodsCheck</code> is defined here, each <code>tripod</code> can define its own transaction check logic.</p>
<p><code>VerifyBlock()</code> is a developer-defined block verification logic. Every time the blockchain receives a block from external broadcast, it needs to be verified before it can be processed. Different chains have different verifications for blocks. test method, so
Developers can customize the validation logic by themselves. Each <code>tripod</code> can define its own transaction checking logic.</p>
<h2><a class="header" href="#-10" id="-10"></a></h2>
<pre><code class="language-go">func InitChain() 
func StartBlock(block *Block) 
func EndBlock(block *Block)
func FinalizeBlock(block *Block)
</code></pre>
<p><code>InitChain()</code> will only be called once when the blockchain is started, and it is specially used to define and process the <code>genesis block</code>.<br />
<code>StartBlock()</code> defines the logic of the stage when the block is generated.<br />
<code>EndBlock()</code> defines the logic at the end of the block, where the transaction is generally executed and the block is stored in the blockchain.<br />
<code>FinalizeBlock()</code> defines the logic of the block's <code>finalize phase</code> (i.e. final consensus). If the blockchain is a <code>finalize type chain</code>, you need to customize this part of the logic, otherwise it is not necessary.</p>
<h3><a class="header" href="#dependency-injection" id="dependency-injection">Dependency Injection</a></h3>
<p>We may develop many Tripods in yu, and there may be dependencies between different Tripods. For example, when a developer develops a Tripod named <code>staking</code>, it may need to rely on the <code>asset</code> Tripod.
In order to facilitate developers to manage Tripod dependencies more conveniently. yu provides the function of dependency injection.</p>
<pre><code class="language-go">type Staking struct {
	*tripod.Tripod
	asset *asset.Asset `tripod:&quot;asset&quot;`
}
</code></pre>
<p>As shown above, it is known that we already have an <a href="https://github.com/yu-org/yu/blob/master/apps/asset/transfer.go">Asset Tripod</a>. Now we develop the pledge module, which needs to rely on the assets in the asset
Some functions, then we only need to declare the asset variable in the Staking structure and add a tag (<code>tripod:&quot;asset&quot;</code>).
This is a fixed syntax <code>tripod:&lt;TripodName&gt;</code>, after adding, we just need to start yu normally:</p>
<pre><code class="language-go">    startup.SyncAndStartup(Staking.New(), asset.NewAsset())
</code></pre>
<p>Simple as above. <code>SyncAndStartup()</code> is a necessary step to start yu, you only need to call it once in your code, Startup() will automatically load these Tripods and complete dependency injection at runtime.</p>
<h2><a class="header" href="#land" id="land">land</a></h2>
<p><code>land</code> is used to load all <code>tripod</code>s for the framework to call.</p>
<h4><a class="header" href="#land-internal-flow-chart" id="land-internal-flow-chart"><code>land</code> internal flow chart</a></h4>
<p><img src="land%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image" /></p>
<h1><a class="header" href="#state" id="state">State</a></h1>
<p><code>state</code> is the state storage on the chain. For example, after A initiates an on-chain transfer to B, the account balance information of A and B will be stored. Below we refer to all operations on the state store in each transaction as a <code>transaction</code>.<br />
Transactions in <code>state</code> are atomic. For example, there are 3 operations that modify the state in a transaction, then these 3 operations can either be modified successfully, or none of them are successful.<br />
eg:</p>
<pre><code class="language-go">func (a *A) DoTest(ctx *context.WriteContext) error {
    a.State.Set(a, []byte(&quot;yu&quot;), []byte(&quot;yu&quot;)) // 1. Mute state

    err := DoOther()
    if err != nil {
        return err
    }

    a.State.Set(a, []byte(&quot;qi&quot;), []byte(&quot;qi&quot;)) // 2. Mute state
}
</code></pre>
<p>In the above code, there are two <code>Mute state</code> operations. If the code executes successfully in the first place, but returns an error in <code>DoOther()</code>, then the <code>modify state</code> in the second place cannot be completed. at this time
The framework will also cancel the first state modification to ensure atomicity.</p>
<p>Currently, only the storage form of kvdb is supported internally. The state is stored in blocks, and the transactions in each block are executed in sequence and stored in the database. </p>
<p>Code is <a href="https://github.com/yu-org/yu/blob/master/core/state/kv.go">here</a></p>
<pre><code class="language-go">func StartBlock(blockHash)
</code></pre>
<p><code>StartBlock()</code> is called during the <code>start block</code> phase of the blockchain operation to tell <code>state</code> the current block hash.</p>
<pre><code class="language-go">func SetCanRead(blockHash)
</code></pre>
<p><code>SetCanRead()</code> sets the state in the block that can currently be read. After a block transaction is executed and stored in the chain, it may not be allowed to be read immediately, especially the <code>finalize type chain</code>, which requires
The result state of the Writing in the block can not be read by the outside world until the block is <code>finalized</code>. Of course <code>non-finalized chains</code> can be read as soon as the block is stored in the chain.</p>
<pre><code class="language-go">func Commit() (Hash, error)
</code></pre>
<p><code>Commit()</code> commits all transactions in the block and returns the <code>stateroot</code> of the state tree under the block.</p>
<pre><code class="language-go">func Discard()
</code></pre>
<p><code>Discard()</code> discards current transaction.</p>
<pre><code class="language-go">func DiscardAll()
</code></pre>
<p><code>DiscardAll()</code> discards all transactions in the current block.</p>
<pre><code class="language-go">func NextTxn()
</code></pre>
<p><code>NextTxn()</code> indicates that the current transaction is completed and the next transaction is started.</p>
<h1><a class="header" href="#p2p-network" id="p2p-network">P2P network</a></h1>
<p><code>p2p</code> is the network foundation of the blockchain. For a customizable blockchain framework, <code>yu</code> allows developers to freely use the functions of the P2P network, and developers can call it in <code>ChainEnv</code>.
The underlying implementation of this interface comes from <a href="https://github.com/libp2p/go-libp2p">libp2p</a></p>
<h4><a class="header" href="#interface-3" id="interface-3">Interface</a></h4>
<p>Code is <a href="https://github.com/yu-org/yu/tree/master/infra/p2p">here</a> ，the core functions are as follows：</p>
<pre><code class="language-go">    LocalID() peer.ID
    GetBootNodes() []peer.ID
    ConnectBootNodes() error
</code></pre>
<p><code>LocalID()</code> returns local p2p ID<br />
<code>GetBootNodes()</code> returns the p2p IDs of the <code>bootnodes</code> nodes in the p2p network, <code>bootnodes</code> are configured in the configuration file.<br />
<code>ConnectBootNodes()</code> connects these <code>bootnodes</code></p>
<h2><a class="header" href="#-11" id="-11"></a></h2>
<pre><code class="language-go">    AddTopic(topicName string)
    PubP2P(topic string, msg []byte) error
    SubP2P(topic string) ([]byte, error)
</code></pre>
<p><code>AddTopic()</code> adds a <code>topic</code> to the P2P network, which is used as a topic for subscription publishing.<br />
<code>PubP2P()</code> publishes messages into the <code>topic</code><br />
<code>SubP2P()</code> subscribes messages from the <code>topic</code></p>
<h2><a class="header" href="#-12" id="-12"></a></h2>
<pre><code class="language-go">    RequestPeer(peerID peer.ID, code int, request []byte) (response []byte, err error)
    SetHandlers(handlers map[int]dev.P2pHandler)
</code></pre>
<p><code>RequestPeer()</code> sends request data to a specific p2p node, <code>code</code> is the request category, which can be customized. (except <code>100</code> and <code>101</code>, these two are predefined <code>code</code> of the framework, <code>100</code> is used when P2P node connection comparison data;
<code>101</code> is used when synchronizing transaction data)<br />
<code>SetHandlers()</code> is set to handle requests from the P2P network, each <code>code</code> corresponds to a <code>handler</code>, the interface of <code>handler</code> is  <a href="https://github.com/yu-org/yu/blob/master/core/tripod/dev/funcs.go#L19">here</a> , developers can customize the logic here.</p>
<h1><a class="header" href="#development-manual" id="development-manual">Development Manual</a></h1>
<p>This chapter will go into the details of how to develop a blockchain with <code>yu</code>. i.e. how to build your own <code>tripod</code>.</p>
<p>The default path of the configuration file is <code>yu_conf/kernel.toml</code>. If you need to configure it separately, please use <code>-k</code> to specify the path of the configuration file.<br />
Of course, if you don't want to configure the file yourself, you can also use <code>-dc</code> to enable the system default configuration. However, it should be noted that the default configuration of the system does not connect to any <code>bootnodes</code>.</p>
<h1><a class="header" href="#config-file" id="config-file">Config File</a></h1>
<p>The format of the yu configuration file is <code>.toml</code>.<br />
The configuration content is divided into the following parts， code is <a href="https://github.com/yu-org/yu/blob/master/config/config.go">here</a></p>
<ul>
<li>Node Config</li>
<li>each Component Config</li>
<li>P2P Config</li>
</ul>
<p>The default configuration file path for <code>yu</code> is <code>yu_conf/kernel.toml</code>. Of course, if you don't want to fill in the configuration file manually, you can also enable the command line as in [Quick Start] (2. Quick Start.md)
<code>-dc=true</code> to take advantage of the default configuration. The source address of the default configuration is <a href="https://github.com/yu-org/yu/blob/master/config/default.go">here</a></p>
<h1><a class="header" href="#节点配置" id="节点配置">节点配置</a></h1>
<h4><a class="header" href="#源码样式" id="源码样式">源码样式：</a></h4>
<pre><code class="language-go">    // 0: local-node 
    //1: master-worker
    RunMode RunMode `toml:&quot;run_mode&quot;`
    // serve http port
    HttpPort string `toml:&quot;http_port&quot;`
    // serve websocket port
    WsPort string `toml:&quot;ws_port&quot;`
    // log out level:
    // panic, fatal, error, warn, info, debug, trace
    LogLevel string `toml:&quot;log_level&quot;`
    
    LeiLimit uint64 `toml:&quot;lei_limit&quot;`
</code></pre>
<ul>
<li>Runmode:  the node operation mode, 0 is for single-node operation, 1 is for <code>master-worker</code> operation (<code>master-worker</code> is not currently supported)</li>
<li>HttpPort: http listening address, port configuration for serving external calls. </li>
<li>WsPort:  the websocket listening address, the port configuration for serving external calls.</li>
<li>LogLevel: print the level of the log, from top to bottom, there are <code>panic</code>, <code>fatal</code>, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code></li>
<li>LeiLimit：the upper limit of <code>lei</code> that can be consumed per block </li>
</ul>
<h4><a class="header" href="#配置示例" id="配置示例">配置示例：</a></h4>
<pre><code class="language-toml">run_mode = 0

http_port = &quot;7998&quot;

ws_port = &quot;8998&quot;

log_level = &quot;info&quot;

lei_limit = 50000
</code></pre>
<h1><a class="header" href="#各组件配置" id="各组件配置">各组件配置</a></h1>
<h4><a class="header" href="#blockchainconfig-codes" id="blockchainconfig-codes"><code>blockchain</code>config codes:</a></h4>
<pre><code class="language-go">type BlockchainConf struct {
	ChainDB         SqlDbConf `toml:&quot;chain_db&quot;`
}
</code></pre>
<ul>
<li>ChainDB: The sql database used to store the blockchain.</li>
</ul>
<h4><a class="header" href="#txdbconfig-codes" id="txdbconfig-codes"><code>txdb</code>config codes:</a></h4>
<pre><code class="language-go">type txdbConf struct {
	BaseDB SqlDbConf `toml:&quot;base_db&quot;`
}
</code></pre>
<ul>
<li>BaseDB: The sql database used to store <code>txdb</code>.</li>
</ul>
<h4><a class="header" href="#txpoolconfig-codes" id="txpoolconfig-codes"><code>txpool</code>config codes:</a></h4>
<pre><code class="language-go">type TxpoolConf struct {
	PoolSize   uint64    `toml:&quot;pool_size&quot;`
	TxnMaxSize int       `toml:&quot;txn_max_size&quot;`
}
</code></pre>
<ul>
<li>PoolSize: The size of the transaction pool, if it exceeds this size, subsequent transactions will not be put into the transaction pool.</li>
<li>TxnMaxSize：The data size of the maximum transaction, if a transaction exceeds this configuration, it will not be put into the transaction pool.</li>
</ul>
<h4><a class="header" href="#stateconfig-codes" id="stateconfig-codes"><code>state</code>config codes:</a></h4>
<pre><code class="language-go">type StateConf struct {
	KV StateKvConf `toml:&quot;kv&quot;`
}
</code></pre>
<p>At present, <code>state</code> only supports <code>kvdb</code> storage method, and more storage forms will be opened in the future </p>
<h3><a class="header" href="#config-example" id="config-example">Config Example:</a></h3>
<pre><code class="language-toml">[block_chain.chain_db]
sql_db_type = &quot;sqlite&quot;
dsn = &quot;chain.db&quot;



[yu_db.base_db]
sql_db_type = &quot;sqlite&quot;
dsn = &quot;txdb.db&quot;

[txpool]
pool_size = 2048
txn_max_size = 1024000

[state.kv.index_db]
kv_type = &quot;bolt&quot;
path = &quot;./state_index.db&quot;

[state.kv.node_base]
kv_type = &quot;bolt&quot;
path = &quot;./state_base.db&quot;
</code></pre>
<h1><a class="header" href="#p2p-config" id="p2p-config">p2p Config</a></h1>
<h4><a class="header" href="#config-codes" id="config-codes">Config codes:</a></h4>
<pre><code class="language-go">    // For listening from blockchain network.
	P2pListenAddrs []string `toml:&quot;p2p_listen_addrs&quot;`
	// To connect other hosts as a p2p network.
	Bootnodes []string `toml:&quot;bootnodes&quot;`

	ProtocolID string `toml:&quot;protocol_id&quot;`
	// 0: RSA
	// 1: Ed25519
	// 2: Secp256k1
	// 3: ECDSA
	NodeKeyType int `toml:&quot;node_key_type&quot;`

	NodeKeyRandSeed int64 `toml:&quot;node_key_rand_seed&quot;`

	NodeKey string `toml:&quot;node_key&quot;`

	// Only RSA has this param.
	NodeKeyBits int `toml:&quot;node_key_bits&quot;`
	// When use param 'NodeKey', 'NodeKeyFile' will not work.
	NodeKeyFile string `toml:&quot;node_key_file&quot;`
</code></pre>
<ul>
<li>P2pListenAddrs: Indicates the address of the P2P protocol that the blockchain node listens to</li>
<li>Bootnodes:  Link other blockchain nodes in the P2P network to synchronize historical blocks</li>
<li>ProtocolID: Customized protocol name in P2P network</li>
<li>NodeKeyType: The encryption type of the key of the P2P node, which is used to generate the key of the p2p address. </li>
<li>Four encryption algorithms are currently supported:
<ul>
<li><code>0</code>: <code>RSA</code></li>
<li><code>1</code>: <code>Ed25519</code></li>
<li><code>2</code>: <code>Secp256k1</code></li>
<li><code>3</code>: <code>ECDSA</code></li>
</ul>
</li>
<li>NodeKeyRandSeed: Generate the seed of the key of the p2p node, which is used to generate the key of the P2P address. When this item is not empty, there is no need to configure <code>NodeKey</code>.</li>
<li>NodeKey：The key of the P2P address, used to generate the p2p address. When <code>NodeKeyRandSeed</code> is not empty, this item can be left blank.</li>
<li>NodeKeyBits: The bits of the key. This configuration is only required for the encryption algorithm <code>RSA</code>. Other types of encryption algorithms do not need to configure this parameter.</li>
<li>NodeKeyFile: Read the key file of the p2p address. Only when <code>NodeKey</code> is empty, the system will read this configuration item.</li>
</ul>
<h4><a class="header" href="#config-example-1" id="config-example-1">Config Example：</a></h4>
<pre><code class="language-toml">
p2p_listen_addrs = [&quot;/ip4/127.0.0.1/tcp/8887&quot;]

protocol_id = &quot;yu&quot;

node_key_type = 1
node_key_rand_seed = 1
</code></pre>
<h1><a class="header" href="#context-and-chainenv" id="context-and-chainenv">Context and ChainEnv</a></h1>
<p>In <a href="2.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html">Quick Start</a>, we have seen how to customize an <code>Writing</code>, there are two parameters here, one is <code>context</code>, the other is <code>ChainEnv</code>, they represent two different
the use of.</p>
<p><a href="https://github.com/yu-org/yu/blob/master/core/context">Context</a> represents contextual information for interactions with off-chain. It includes <code>caller address</code>, <code>passed parameters</code> 、
<code>event</code>、<code>error</code>。</p>
<ul>
<li>The parameters passed in by the client caller (that is, the person who initiated the transaction) will be serialized in the form of json and stored in <code>context</code> in the form of <code>string -&gt; interface{}</code> map.
We use <code>context</code> to get the <code>cryptographic address</code> of the client caller and the <code>parameters</code> passed in by the caller. from <code>context</code>
When getting parameters, you can use <a href="https://github.com/yu-org/yu/blob/master/core/context/params.go">any go basic type</a> to get parameters.
If the parameter type is custom, you need to obtain <code>interface</code> through <code>context.Get(paramName)</code> and then convert it yourself. The types of parameters that can be directly obtained are:</li>
</ul>
<pre><code class="language-go">   common.Hash([32]byte)
   common.Address([20]byte)
   string
   []byte
   bool 
   int, int8, int16, int32, int64
   uint, uint8, uint16, uint32, uint64
   float32, float64
</code></pre>
<ul>
<li>At the same time, if you need to return <code>event</code> out of the chain, you also need to complete it through <code>context</code> (<code>ctx.EmitEvent([]byte)</code>).</li>
</ul>
<p><a href="https://github.com/yu-org/yu/blob/master/core/env/env.go">ChainEnv</a> contains all environment components related to all chains, including <code>blockchain</code>,
<code>txdb</code>, <code>txpool</code>, <code>state</code>, <code>Execute</code>, <code>P2pNetwork</code>. Components that can be directly manipulated by developers to the bottom layer of the framework.  </p>
<h1><a class="header" href="#writing-and-reading" id="writing-and-reading">Writing and Reading</a></h1>
<p>Under normal circumstances, developers will use more <code>Writing</code> and <code>Reading</code>, because these are basically external read and write interfaces at the business level. So in this section we look at how in <code>yu</code>
use them. The code is <a href="https://github.com/yu-org/yu/blob/master/core/tripod/dev/funcs.go">here</a></p>
<p>Defined as follows:</p>
<pre><code class="language-go">type (
    Writing func(ctx *WriteContext) error

    Reading func(ctx *ReadContext) error
	
	P2pHandler func([]byte) ([]byte, error)
)
</code></pre>
<ul>
<li>
<p><code>Writing</code> is called <code>transaction</code> in other blockchains such as Ethereum. In the final analysis, it is <code>a write operation to the state on the chain</code>, so such an operation will be synchronized to the entire network.
When you need to modify the state on the chain, you need to call <code>chainEnv.KVDB</code> to modify the state. Note that the first parameter of the <code>set</code>, <code>get</code>, <code>delete</code> functions in <code>chainEnv.kvdb</code> must be the current <code>tripod</code>
Pointer, such as <code>e.State.Set(e, ..., ...)</code> in <a href="2.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html">Quick Start</a><br />
<code>currentBlock</code> is the block that the current transaction is in.<br />
<code>ctx.EmitEvent()</code> is called when <code>event</code> needs to be sent off-chain.</p>
</li>
<li>
<p><code>Reading</code> is an on-chain query. It does not modify the on-chain state, so the operation will not be synchronized to the entire network.<br />
Status query calls <code>env.KVDB.Get()</code> or <code>env.KVDB.GetByBlockHash()</code>. The former is to query the status that the final consensus has been reached on the main chain; the latter is to query the status of a specific block.
historical state.<br />
<code>respObj</code> is used to return the queried status value to the off-chain.</p>
</li>
<li>
<p><code>P2pHandler</code> is to define and process requests from the P2P network. For example, when a node needs to broadcast or send a processing request to a specific node, this function can be customized to complete the custom function.</p>
</li>
<li>
<p><code>Inject into Tripod</code>：When building all our <code>Writing</code> and <code>Reading</code>, we need to call <code>tripod.SetWritings()</code> to inject all <code>Writing</code> into <code>tripod</code>,
And call <code>tripod.SetReadings()</code> to inject all <code>Reading</code> into <code>tripod</code>.</p>
</li>
<li>
<p><code>Load into land</code>：The framework provides a <a href="https://github.com/yu-org/yu/blob/master/startup/startup.go#L31">SyncAndStartup entry</a> as long as the startup
Load all the <code>tripod</code>s we built by calling <code>SyncAndStartup(...Tripod)</code>, thereby telling the framework which <code>tripod</code>s we have customized.</p>
</li>
</ul>
<h4><a class="header" href="#about-defaulttripod" id="about-defaulttripod">About <code>defaultTripod</code></a></h4>
<p>[defaultTripod](https://github.com/yu-org/yu/blob/master/tripod/ default_tripod.go)
It can help you write a lot less code, you need to put it in the first member variable of the <code>tripod</code> structure of your custom implementation (you must omit the variable name to achieve the effect of inheriting <code>defaultTripod</code>). 
as follows：</p>
<pre><code class="language-go">type Example struct {
	*tripod.Tripod
}
</code></pre>
<h1><a class="header" href="#block-lifecycle" id="block-lifecycle">Block Lifecycle</a></h1>
<p><a href="4.4tripod.html">Previous</a> has introduced the concept of block cycle in <code>tripod</code> in detail. By customizing the block cycle, we can implement many deep functions, such as consensus algorithms. Below we use
Take pow consensus as an example, the original code address <a href="https://github.com/yu-org/yu/blob/master/apps/pow/pow.go">here</a></p>
<ul>
<li>Init blockchain，build a genesis block.</li>
</ul>
<pre><code class="language-go">    func (p *Pow) InitChain() error {
        // build a genesis block and append chain.
        chain := p.env.Chain
        gensisBlock := &amp;types.Block{
            Header: &amp;types.Header{},
        }
        err := chain.SetGenesis(gensisBlock)
        if err != nil {
            return err
        }
        // Start a gorotine to pull data from other nodes in the P2P network in real time
        go func() {
            for {
                msg, err := p.env.P2pNetwork.SubP2P(StartBlockTopic)
                if err != nil {
                    logrus.Error(&quot;subscribe message from P2P error: &quot;, err)
                    continue
                }
                p.msgChan &lt;- msg
            }
        }()
        return nil
    }
</code></pre>
<ul>
<li>Block starts，build a new block</li>
</ul>
<pre><code class="language-go">func (p *Pow) StartBlock(block *Block) error {
    pool := p.env.Pool
    // If a block from another node is received before the local node produces a block, the mining will be skipped after verification and the block will be directly stored in the chain.
    // If there is none or the block is invalid, the local node starts mining.
    if p.UseBlocksFromP2P(block) {
        logrus.Infof(&quot;--------USE P2P block(%s)&quot;, block.Hash.String())
        return nil
    }
	
    // Pack transactions from txpool.
    txns, err := pool.Pack(p.packLimit)
	if err != nil {
        return err
    }
	
    ......
    // Start to mining.
    nonce, hash, err := spow.Run(block, p.target, p.targetBits)
    if err != nil {
        return err
    }
	
    ......
    // After mining, the block is broadcast to the P2P network.
    return p.env.P2pNetwork.PubP2P(StartBlockTopic, rawBlockByt)
}
</code></pre>
<ul>
<li>End block</li>
</ul>
<pre><code class="language-go">func (*Pow) EndBlock(block *Block) error {
    chain := p.env.Chain
    pool := p.env.Pool
    
    // Execute the transactions of the block.
    err := p.env.Execute(block)
    if err != nil {
        return err
    }
    
    // Store blocks in the chain for persistence.
    err = chain.AppendBlock(block)
    if err != nil {
        return err
    }
    
    return pool.Reset(block)
}

</code></pre>
<ul>
<li>Final consensus, finalizing the block：
Since the pow consensus generally does not require the finalization stage of the final consensus, because they have the longest sub-chain or the heaviest sub-chain to prove the computing power. So here we don't need to implement <code>FinalizeBlock()</code>. </li>
</ul>
<pre><code class="language-go">func (*Pow) FinalizeBlock(_ *Block) error {
	return nil
}
</code></pre>
<p>So far, a pow consensus mechanism based on sha256 is completed.</p>
<h1><a class="header" href="#build-a-blockchain-network" id="build-a-blockchain-network">Build a blockchain network</a></h1>
<p>When we have completed the <a href="5.0dev.html">configuration file</a>, we can start building the blockchain network by ourselves.<br />
In this chapter, we choose to compile <a href="https://github.com/yu-org/yu/tree/master/example/master">example</a> to start the blockchain node, in this example
Loaded with <a href="https://github.com/yu-org/yu/tree/master/apps/pow">pow consensus</a> and <a href="https://github.com/yu-org/yu/tree/master/apps/asset">asset module</a>.
Of course, we can also customize <code>tripod</code> to replace <code>pow</code> and <code>asset</code> or add more <code>tripod</code>.<br />
First we use <a href="5.5.1%E8%8A%82%E7%82%B91.html">the configuration file</a> to start the first blockchain node locally: </p>
<pre><code class="language-shellscript">INFO[0000] register Writing(Transfer) into Tripod(asset)
INFO[0000] register Writing(CreateAccount) into Tripod(asset)
INFO[0000] register Query(QueryBalance) into Tripod(asset)
INFO[2021-07-25 11:11:09] I am /ip4/127.0.0.1/tcp/8887/p2p/12D3KooWHHzSeKaY8xuZVzkLbKFfvNgPPeKhFBGrMbNzbm5akpqu
INFO[2021-07-25 11:11:11] start block...................
INFO[2021-07-25 11:11:11] prev-block hash is (0x0000000000000000000000000000000000000000000000000000000000000000), height is (0)
INFO[2021-07-25 11:11:11] [[[Mining a new Block!!!]]]
655111533297e8df7319ce54a0ed74f643940831f388211a1fe985960c82fe75
INFO[2021-07-25 11:11:11] append block(1)
INFO[2021-07-25 11:11:13] start block...................
INFO[2021-07-25 11:11:13] prev-block hash is (0x0000337defe7b4412c872bd42a6d21626ea6a57c3d695379efb8b447d67a1bbd), height is (1)
INFO[2021-07-25 11:11:13] [[[Mining a new Block!!!]]]
c64e251d8617a96b80a1d8ff5b74cceef20fa9750bdbc7d095f87791ce01fc88
INFO[2021-07-25 11:11:13] append block(2)
INFO[2021-07-25 11:11:15] start block...................
INFO[2021-07-25 11:11:15] prev-block hash is (0x00005ecc8b50fbc01d32330c5cdd1574a1f0ead527a94f54f326ecaad0473ffb), height is (2)
INFO[2021-07-25 11:11:15] [[[Mining a new Block!!!]]]
819da2117ca553f098a1b16c1ad95f2e10498a5df855f5980d8a54c183b302e2
b062934ef239c48553a43591d451878a1f31abe0a72400f18d7daf4055e22625
INFO[2021-07-25 11:11:15] append block(3)
</code></pre>
<p>Note: In the information output above, the string of addresses after <code>I am</code> is the p2p address generated by node1 itself, and node 2 and node 3 need to connect to this address to build a blockchain network.</p>
<p>Then we write the <a href="5.5.2%E8%8A%82%E7%82%B92.html">configuration file</a> in another path to deploy the second node and start it:</p>
<pre><code class="language-shellscript">INFO[0000] register Writing(Transfer) into Tripod(asset)
INFO[0000] register Writing(CreateAccount) into Tripod(asset)
INFO[0000] register Query(QueryBalance) into Tripod(asset)
INFO[2021-07-25 11:11:17] I am /ip4/127.0.0.1/tcp/8886/p2p/12D3KooWEsGugZfk1eWUGf4oUXksvfA9QoCX8etf745SVEyiZFXQ
INFO[2021-07-25 11:11:17] start to sync history from other node
INFO[2021-07-25 11:11:17] fetch history blocks from (1) to (3)
INFO[2021-07-25 11:11:19] start block...................
INFO[2021-07-25 11:11:19] prev-block hash is (0x000046787b43397f7aa4bd1b59ecc9a25e0691086db15ef1613c0e7eeefe3c9a), height is (3)
INFO[2021-07-25 11:11:19] USE P2P block(0x00007536afbeaf2ed6e84c449b7b17836280490711b85e676b77c21d75d31f22)
INFO[2021-07-25 11:11:19] append block(4)
INFO[2021-07-25 11:11:21] start block...................
INFO[2021-07-25 11:11:21] prev-block hash is (0x00007536afbeaf2ed6e84c449b7b17836280490711b85e676b77c21d75d31f22), height is (4)
INFO[2021-07-25 11:11:21] USE P2P block(0x0000ebd7752fc71f0cc27740763c27ec9db87dd91fd781f07316744c98196806)
INFO[2021-07-25 11:11:21] append block(5)
</code></pre>
<p>In the output of the above figure, <code>fetch history blocks from (1) to (3)</code> means that when node 2 starts, the history blocks from height 1 to 3 are obtained from node 1</p>
<p>Finally, we write the <a href="5.5.3%E8%8A%82%E7%82%B93.html">configuration file</a> in the third path to deploy the second node and start it:</p>
<pre><code class="language-shellscript">INFO[0000] register Writing(Transfer) into Tripod(asset)
INFO[0000] register Writing(CreateAccount) into Tripod(asset)
INFO[0000] register Query(QueryBalance) into Tripod(asset)
INFO[2021-07-25 11:11:24] I am /ip4/127.0.0.1/tcp/8885/p2p/12D3KooWGcd7wei9ndo1uSZKap3s8X2E3kxN674xGo8prJUBSezD
INFO[2021-07-25 11:11:24] start to sync history from other node
INFO[2021-07-25 11:11:24] fetch history blocks from (1) to (7)
INFO[2021-07-25 11:11:26] start block...................
INFO[2021-07-25 11:11:26] prev-block hash is (0x00002b56e478552f309b208e90cae288f8f809e2ccefd788730d55ea5e39e1e1), height is (7)
INFO[2021-07-25 11:11:26] USE P2P block(0x0000f86034bf5e2fe3cd308d08ad0dab1b61c41e7f722c489c14e1215acd0990)
INFO[2021-07-25 11:11:26] append block(8)
INFO[2021-07-25 11:11:28] start block...................
INFO[2021-07-25 11:11:28] prev-block hash is (0x0000f86034bf5e2fe3cd308d08ad0dab1b61c41e7f722c489c14e1215acd0990), height is (8)
INFO[2021-07-25 11:11:28] USE P2P block(0x000018f47c74dafca4a54596d5284fb320050f1cd3817a87864074cb602e2d15)
INFO[2021-07-25 11:11:28] append block(9)
</code></pre>
<p>In the output of the above figure, <code>fetch history blocks from (1) to (7)</code> indicates that when node 3 starts, the history blocks from height 1 to 7 are obtained from node 1</p>
<h1><a class="header" href="#node1-config" id="node1-config">Node1 Config</a></h1>
<pre><code class="language-toml">run_mode = 0
http_port = &quot;7999&quot;
ws_port = &quot;8999&quot;
log_level = &quot;info&quot;
log_output = &quot;yu.log&quot;
lei_limit = 50000
timeout = 60

[p2p]
p2p_listen_addrs = [&quot;/ip4/127.0.0.1/tcp/8887&quot;]
protocol_id = &quot;yu&quot;
node_key_type = 1
node_key_rand_seed = 1

[kvdb]
kv_type = &quot;bolt&quot;
path = &quot;./yu.db&quot;

[block_chain.chain_db]
sql_db_type = &quot;sqlite&quot;
dsn = &quot;chain.db&quot;

[txpool]
pool_size = 2048
txn_max_size = 1024000
</code></pre>
<h1><a class="header" href="#node2-config" id="node2-config">Node2 Config</a></h1>
<pre><code class="language-toml">run_mode = 0
http_port = &quot;7998&quot;
ws_port = &quot;8998&quot;
log_level = &quot;info&quot;
log_output = &quot;yu.log&quot;
lei_limit = 50000
timeout = 60

[p2p]
p2p_listen_addrs = [&quot;/ip4/127.0.0.1/tcp/8886&quot;]
# This configuration is the P2P address printed out when node 1 starts up
bootnodes = [&quot;/ip4/127.0.0.1/tcp/8887/p2p/12D3KooWHHzSeKaY8xuZVzkLbKFfvNgPPeKhFBGrMbNzbm5akpqu&quot;]
protocol_id = &quot;yu&quot;
node_key_type = 1

[kvdb]
kv_type = &quot;bolt&quot;
path = &quot;./yu.db&quot;

[block_chain.chain_db]
sql_db_type = &quot;sqlite&quot;
dsn = &quot;chain.db&quot;

[txpool]
pool_size = 2048
txn_max_size = 1024000
</code></pre>
<h1><a class="header" href="#node3-config" id="node3-config">Node3 Config</a></h1>
<pre><code class="language-toml">run_mode = 0
http_port = &quot;3998&quot;
ws_port = &quot;3998&quot;
log_level = &quot;info&quot;
log_output = &quot;yu.log&quot;
lei_limit = 50000
timeout = 60

[p2p]
p2p_listen_addrs = [&quot;/ip4/127.0.0.1/tcp/8885&quot;]
# This configuration is the P2P address printed out when node 1 starts up
bootnodes = [&quot;/ip4/127.0.0.1/tcp/8887/p2p/12D3KooWHHzSeKaY8xuZVzkLbKFfvNgPPeKhFBGrMbNzbm5akpqu&quot;]
protocol_id = &quot;yu&quot;
node_key_type = 1

[block_chain.chain_db]
sql_db_type = &quot;sqlite&quot;
dsn = &quot;chain.db&quot;

[kvdb]
kv_type = &quot;bolt&quot;
path = &quot;./yu.db&quot;

[txpool]
pool_size = 2048
txn_max_size = 1024000
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
